# PatternForJavaAndAndroid
Java反射基础知识

##理解Class对象
##RRTI的概念以及Class对象的作用
RRTI（Run-Time Type Identification）运行时类型识别
其作用是在运行时识别一个对象的类型和类的信息，这里分两种：
传统的RRTI,它假定我们在编译期已经知道了所有类型，
比如new对象时该类必须已定义好（在没有反射机制的创建和使用类对象时），
另外一种是反射机制，它允许我们在运行时发现和使用类型的信息。
在java中用来表示运行时信息的对应类就是Class类，
Class类也是一个实实在在的类在JDK的java.lang包中

Class类被创建后的对象就是Class对象，注意，class对象表示的是自己手动编写类的类型信息
实际上在java汇总每个类都有一个class对象，这个对象会被保存在同名.class文件里
（编译后的字节码文件保存的就是class对象）
那为啥需要这样一个对象呢，当我们new 一个新对象或者引用静态成员变量时，JVM中的类加载器子系统会将
对应的class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象创建我们需要的实例对象

需要特别注意的是手动编写的每个Class类，无论创建多少个实例对象，在JVM中都只有一个Class对象
即在内存中每个类有且只有一个相对应的Class对象
关键信息：
1.Class类也是类的一种，与class关键字是不一样的
2.手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，
而且这个Class对象保存在同名.class的文件中(字节码文件)，
比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，
并保存在Shapes.class字节码文件中。
3.每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，
无论创建多少个实例对象，其依据的都是用一个Class对象
4.Class对象只存有私有构造函数，因此对应Class对象只能由JVM创建和加载
5.Class类的对象作用是运行时提供某个对象的类型信息

#Class对象的加载
前面我们已提到过，Class对象是由JVM加载的，
那么其加载时机是？实际上所有的类都是在对其第一次使用时动态加载到JVM中的，
当程序创建第一个对类的静态成员引用时，就会加载这个被使用的类(实际上加载的就是这个类的字节码文件)，
注意，使用new操作符创建类的新实例对象也会被当作对类的静态成员的引用(构造函数也是类的静态方法)，
由此看来Java程序在它们开始运行之前并非被完全加载到内存的，其各个部分是按需加载，
所以在使用该类时，类加载器首先会检查这个类的Class对象是否已被加载(类的实例对象创建时依据Class对象中类型信息完成的)，
如果还没有加载，默认的类加载器就会先根据类名查找.class文件(编译后Class对象被保存在同名的.class文件中)，
在这个类的字节码文件被加载时，
它们必须接受相关验证，以确保其没有被破坏并且不包含不良Java代码(这是java的安全机制检测)，
完全没有问题后就会被动态加载到内存中，
此时相当于Class对象也就被载入内存了(毕竟.class字节码文件保存的就是Class对象)，
同时也就可以被用来创建这个类的所有实例对象。



